#include <string.h>
#include <stdio.h>
#include <stm32f10x.h>
#include <utils.h>
#include <spi.h>
#include <seglcd.h>
#include <cormorant.c>

#define LCD_W 128
#define LCD_H 8
uint8_t numfont[10][5] = {
  0x07,0x05,0x05,0x05,0x07, // 0
  0x01,0x01,0x01,0x01,0x01, // 1
  0x07,0x01,0x07,0x04,0x07, // 2
  0x07,0x01,0x07,0x01,0x07, // 3
  0x05,0x05,0x07,0x01,0x01, // 4
  0x07,0x04,0x07,0x01,0x07, // 5
  0x07,0x04,0x07,0x05,0x07, // 6
  0x07,0x01,0x01,0x01,0x01, // 7
  0x07,0x05,0x07,0x05,0x07, // 8
  0x07,0x05,0x07,0x01,0x07 // 9
};
uint8_t boxfont[4] = {0x0F, 0x0B, 0x0D, 0x0F};

int score = 0;
int level = 0;
int hiscore = 0;
bool display[30][10];

uint8_t LCD_Buf[LCD_H][LCD_W] = {0x00, 0x00, 0xee, 0xa8, 0xee, 0xc8, 0xae, 0x00, 0x00, 0x00, 0xea, 0x8a, 0xee, 0xa2, 0xe2, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x88, 0xe8, 0x88, 0xee, 
0x00, 0x00, 0x00, 0x0e, 0x02, 0x0e, 0x08, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x40, 
0x40, 0x46, 0x76, 0x00, 0x00, 0x00, 0xee, 0xaa, 0xee, 0x22, 0xee, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xee, 0x8a, 0x8a, 0x8a, 0xee, 0x00, 0x00, 0x00, 0x2e, 0x22, 0x22, 0x22, 0x22, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x8a, 0xe4, 0x84, 0xe4, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x84, 
0xb7, 0x81, 0x87, 0x00, 0x00, 0x00, 0xee, 0xaa, 0xee, 0x22, 0xee, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xc0, 0x40, 0x4e, 0x48, 0x4e, 0x42, 0x4e, 0x40, 0x40, 0x40, 0x4e, 0x42, 0x4e, 0x42, 0x4e, 0x40, 
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x48, 0x48, 0x48, 0x48, 0x4e, 
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x4a, 0x4a, 
0x4e, 0x4a, 0x4a, 0x40, 0x40, 0x40, 0x4e, 0x4a, 0x4e, 0x42, 0x4e, 0x40, 0x40, 0x40, 0x40, 0x40, 
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 
0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xee, 0xdd, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x6e, 0x5d, 
0x7f, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x87, 0x86, 0x85, 0x87, 0xf8, 0xe8, 0xd8, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

/*`````````````````````````````````````````````````````````````````````````````````````````````````
*   Font definition -- Char cell: 5 x 8 pixels -- PROPORTIONAL spacing.
*   Char cell: 5 x 8 pixels (8 bytes/char); each data byte is a row of 5 pixels.
*
*   Table format: 8 bytes per character --
*          byte[0] bit 7 is descender flag, if true, shift char bitmap down 1 row;
*          byte[0] bits 2:0 specify width of character (1..5 pixels);
*          byte[1:7] (7 bytes) contain the character bitmap image
*
*   Note:  Most chars start on the top row and are 5 dots wide.
*          Upper-case letters are all 5 dots wide (same as mono font), except 'I'.
*          Digits and lower-case letters are mostly 4 dots wide, with a few exceptions,
*          e.g. '1', 'i', 'j', 'l', etc.
*          Descenders use the 8th row in the bitmap cell.
*          Special cases, e.g. 'j', '[', '{', etc, are handled by LCD_PutChar#().
*
*/

//отправит сразу несколько байт
void dat_bulk(uint8_t *data, size_t count){
    GPIOA->ODR |= GPIO_ODR_ODR3;
    GPIOA->ODR &= ~GPIO_ODR_ODR4;
    for (int i=0; i<count; i++) {
       SPI1_Write(data[i]);
    }
    while (SPI1->SR & SPI_SR_BSY);
    GPIOA->ODR |= GPIO_ODR_ODR4; // CS=1
}

void lcdbufPutPixel(uint8_t x, uint8_t y) {
  uint8_t page_address = (x >> 3) % 8;
  y = y % 128;    
  uint8_t column = LCD_Buf[page_address][y];
  column |= (1 << (x % 8));
  LCD_Buf[page_address][y] = column;
}

void lcdbufBlitScreen() {
  cmd(0x40 | 0x00); // Set start line address (Lines 0x00...0x3F)
  for(int k=0; k<=7; k++) { // Clear DRAM
    cmd(0xB0 | k); // Set Page 0 (Pages 0x00...0x0F)
    dat_bulk(LCD_Buf[k], 128);
    cmd(0xEE); // End writing to the page, return the page address back
  }
}

//Обновляет только часть буфера lcdbuf [x .. x+h]x[y .. y+w]
void lcdbufBlitRect(uint8_t x, uint8_t y, uint8_t h, uint8_t w) {
  uint8_t start_addr = (x / 8) % 8;
  uint8_t end_addr = MAX(((x + h) / 8), 7);
  w = MIN(w, 127 - y);
  for (uint8_t page=start_addr; page<=end_addr; page++) {
    cmd(0xB0 | (page & 0x0F));
    cmd(0b00010000 | (y >> 4) & 0x0F);
		cmd(0b00000000 | y & 0x0F);
    dat_bulk(&LCD_Buf[page][y], w + 1);
    cmd(0xEE);
  }
}

void DrawPixel(uint8_t x, uint8_t y){ // x in [0..63], y in [0..127]
  uint8_t page_address = (x >> 3) & 0b00000111; // %8 guarantees page_address in [0..7]
  cmd(0xB0 | page_address); // Set Page page_address (Pages 0x00...0x0F)
  cmd(y & 0b00001111); // Set column address LSB
  cmd(0b00010000 | (y >> 4));
  uint8_t column = LCD_Buf[page_address][y];
  //Set pixel value in LCD_buf
  column |= (1 << (x % 8));
  dat(column);
  LCD_Buf[page_address][y] = column;
}

void DrawChess(){
  uint8_t i,j,k; // i=row number, j=col number, k=cycle inside a square
  uint8_t val = 0x00; // Color 0x00=White strip, 0xFF=black strip
  for(i=0; i<=7; i++){
    cmd(0xB0 | i); // Set Page i (Pages 0x00...0x0F)
    val = ~ val;
    for(j=0; j<=15; j++){
      for(k=0; k<=7; k++) dat(val);
      val = ~val;
    }
    cmd(0xEE);
  }
}

void lcdbufDrawLine(int x0, int y0, int x1, int y1) {
	int delta_x = ABS(x1 - x0);
	int delta_y = ABS(y1 - y0);
	int error = 0;
	
	if (delta_x >= delta_y) {
		//x-direction
		if (x0 > x1) {
			SWAP(x0, x1, int);
			SWAP(y0, y1, int);
		}
		int dir_y = SIGN(y1 - y0);
		int delta_err = delta_y + 1;
		int y = y0;
		for (int x=x0; x<=x1; x++) {
			lcdbufPutPixel(x, y);
			error += delta_err;
			if (error >= delta_x + 1) {
				y += dir_y;
				error -= (delta_x + 1);
			}
		}
	} else { //y-direction
		if (y0 > y1) {
			SWAP(x0, x1, int);
			SWAP(y0, y1, int);
		}
		int dir_x = SIGN(x1 - x0);
		int delta_err = delta_x + 1;
		int x = x0;
		for (int y=y0; y<=y1; y++) {
			lcdbufPutPixel(x, y);
			error += delta_err;
			if (error >= delta_y + 1) {
				x += dir_x;
				error -= (delta_y + 1);
			}
		}
	}
}

void updatebufscore(){
uint8_t d0=score % 10;
uint8_t d1=(score/10) % 10;
uint8_t d2=(score/100) % 10;
uint8_t d3=(score/1000) % 10;
uint8_t d4=(score/10000) % 10;
for(int i=0; i<=4; i++){
  LCD_Buf[0][10+i] = ((numfont[d1][i] << 4) | numfont[d0][i]) << 1;
  LCD_Buf[1][10+i] = ((numfont[d3][i] << 4) | numfont[d2][i]) << 1;
  LCD_Buf[2][10+i] &= 0b11110000;
  LCD_Buf[2][10+i] |= (numfont[d4][i] << 1);
}
lcdbufBlitRect(1,9,19,5);
}



void updatescore(){
// Affects page0 (digits 3-4), page 1 (digits 1-2), page 2 (digit 0)
// Affects columns 10..14 (0x0A..0x0E)

// Update page0 (digits 3-4)
cmd(0xB0 | 0x00); // Set page 0
cmd(0x0A); // Set column 10=0x0A
uint8_t d0=score % 10;
uint8_t d1=(score/10) % 10;
for(int i=0; i<=4; i++)
  dat( ((numfont[d1][i] << 4) | numfont[d0][i]) << 1);

// Update page1 (digits 1-2)
cmd(0xB0 | 0x01); // Set page 1
cmd(0x0A); // Set column 10=0x0A
d0=(score/100) % 10;
d1=(score/1000) % 10;
for(int i=0; i<=4; i++)
  dat( ((numfont[d1][i] << 4) | numfont[d0][i]) << 1);

}

void updatepixel(uint8_t x, uint8_t y, bool s){
  display[x][y] = s;
  // Affects pages 2-7

  uint8_t p0 = ((9-y) / 2) + 3; // p0 and p0-1 pages affected
  // if y%2 == 0 => Only one page is affected
  uint8_t ys = (y % 2 == 0) ? y-1 : y;

  cmd(0xB0 | 0x07); // Set page 7
  cmd(0x01); // Set column 1
  for(int i=0; i<4; i++)
    //dat( (1<<7) | ((boxfont[i] & display[x][0])<<3) | ((boxfont[i] & display[x][1]) >> 1));
    dat(boxfont[i] & (((uint8_t) display[0][0])-2));

  /*cmd(0xB0 | 0x06); // Set page 6
  cmd(0x01); // Set column 1
  for(int i=0; i<4; i++)
    dat( (boxfont[i] & display[x][1])<<7 | (boxfont[i] & display[x][2])<<3 | (boxfont[i] & display[x][3]) >> 1);
  
  cmd(0xB0 | 0x05); // Set page 5
  cmd(0x01); // Set column 1
  for(int i=0; i<4; i++)
    dat( (boxfont[i] & display[x][3])<<7 | (boxfont[i] & display[x][4])<<3 | (boxfont[i] & display[x][5]) >> 1);

  cmd(0xB0 | 0x04); // Set page 4
  cmd(0x01); // Set column 1
  for(int i=0; i<4; i++)
    dat( (boxfont[i] & display[x][5])<<7 | (boxfont[i] & display[x][6])<<3 | (boxfont[i] & display[x][7]) >> 1);

  cmd(0xB0 | 0x03); // Set page 3
  cmd(0x01); // Set column 1
  for(int i=0; i<4; i++)
    dat( (boxfont[i] & display[x][7])<<7 | (boxfont[i] & display[x][8])<<3 | (boxfont[i] & display[x][9]) >> 1);

  cmd(0xB0 | 0x02); // Set page 2
  cmd(0x01); // Set column 1
  for(int i=0; i<4; i++)
    dat( (boxfont[i] & display[x][9])<<7 | (1<<6) );*/



}

int main(void) {

	// Enable clock for GPIOC
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
	// Enable PC13 push-pull mode
	GPIOC->CRH &= ~GPIO_CRH_CNF13; //clear cnf bits
	GPIOC->CRH |= GPIO_CRH_MODE13_0; //Max speed = 10Mhz
  SPI1_Init();
  
  GPIOA->ODR &= ~GPIO_ODR_ODR4; // CS=0
  GPIOA->ODR &= ~GPIO_ODR_ODR2; // RESET=0
  delay(10000); // Wait for the power stabilized
  GPIOA->ODR |= GPIO_ODR_ODR2; // RESET=1
  delay(1000);

  cmd(0xA2); //LCD Drive set 1/9 bias
  cmd(0xA0); // RAM Address SEG Output normal
  cmd(0xC8); // Common outout mode selection
  cmd(0x28 | 0x07); // Power control mode
  cmd(0b00100000 | 0x05); // Voltage regulator
  cmd(0xA6); // Normal color, A7 = inverse color
  cmd(0xAF); // Display on
  cmd(0x40 | 0x00); // Set start line address (Lines 0x00...0x3F)
  //memset(LCD_Buf, 0, sizeof(int8_t) * 8 * 128);
  for(int k=0; k<=7; k++){ // Clear DRAM
    cmd(0xB0 | k); // Set Page 0 (Pages 0x00...0x0F)
    for(int i=0; i<=127; i++){
        dat(LCD_Buf[k][i]);
    }
    cmd(0xEE); // End writing to the page, return the page address back
  }
  updatebufscore();
  //updatepixel(0,0,true);

  // Setting the page address:
  //cmd(0xB0 | 0x00); // Set Page 0 (Pages 0x00...0x0F)
  //
  // Setting the line address:
  //cmd(0x10 | 0x00); // Set column address MSB (0x00...0x0F)
  //cmd(0x00); // Set column address LSB (0x00...0x0F)

  /*for(int i=0; i<64; i++)
    for(int j=0; j<128; j++) {
      if ((i+j) %2 == 0)
        lcdbufPutPixel(i, j);
    }*/
  
  //lcdbufDrawLine(10, 10, 60, 80);
  //lcdbufBlitRect(10, 10, 60 + 10, 10 + 80);

  //char str[] = "Hello";
  //int strlen = 5;
  //PutString(str, strlen);

  //lcdbufBlitScreen();

  //DrawPixel(10, 10);
  //DrawPixel(20, 20);
  //DrawPixel(12, 10);

  //DrawChess();
  
  // String writing example
  //const char* s = "Lazy quick fox jumped over lazy dog";
  //PutString(s, strlen(s), 0, 15);

  //Seglcd_init();
  //DrawBacklan();
  
  //delay(10000000);
  //cmd(0x40 | 0x01); // Set start line address (Lines 0x00...0x3F)
  
    while (1) { // LED blinking
	    GPIOC->ODR |= (1U<<13U); //U -- unsigned suffix (to avoid syntax warnings in IDE)
		  delay(1000000);
	    GPIOC->ODR &= ~(1U<<13U);
	    delay(1000000);
      score+=99;
      updatebufscore();
    }
}